{"version":3,"sources":["webpack:///./src/js/utils/db/Database.js","webpack:///./src/js/utils/asyncFetch.js","webpack:///./src/js/config/index.js","webpack:///./src/js/utils/db/index.js","webpack:///./src/js/utils/db/DBHelper.js","webpack:///./src/js/utils/getUrlParameter.js","webpack:///./src/js/utils/lazyLoadImages.js","webpack:///./src/js/utils/dom.js","webpack:///./src/js/utils/Map/Map.js","webpack:///./src/js/utils/Map/index.js","webpack:///./src/js/config/config.prod.js"],"names":["db_Database","Database","dbName","version","_classCallCheck","this","name","idb_default","a","open","db","objectStoreNames","contains","createObjectStore","keyPath","createIndex","autoIncrement","storeName","data","_connect","then","tx","transaction","Array","isArray","forEach","item","objectStore","put","complete","key","arguments","length","undefined","idx","store","index","getAll","get","delete","clear","_ref","utils_asyncFetch","regeneratorRuntime","mark","_callee","url","wrap","_context","prev","next","fetch","sent","json","abrupt","stop","_x","apply","config","__webpack_require__","default","MODE","js_config","DBHelper","DBHelper_classCallCheck","resource","dbStore","dbKey","dbIndex","Promise","_ref2","DBHelper_asyncToGenerator","resolve","reject","networkResponse","dbResponse","asyncFetch","_this","DB_URL","concat","writeData","t0","readData","message","_x3","_x4","reviews","maxReview","MAX_REVIEW_SCORE","reduce","acc","review","rating","id","_ref3","size","relative","BASE_URL","_fetchResource","_ref4","_this2","_callee3","restaurants","_context3","fetchRestaurants","filter","_ref5","is_favorite","_x5","_x6","restaurantId","reviewId","_ref6","_this3","_callee4","pendingReviews","_context4","map","Object","assign","pending","_toConsumableArray","_x7","_x8","_ref7","_this4","_callee5","restaurant","_context5","fetchRestaurant","fetchRestaurantReviews","averageReview","calculateAverageReview","_x9","_x10","_ref8","_this5","_callee6","fetchOptions","updatedReviews","_context6","method","body","JSON","stringify","headers","Headers","Content-Type","restaurant_id","catch","_x11","_x12","_ref9","_this6","_callee8","_context8","navigator","onLine","Error","clearData","all","_ref10","createdAt","comments","_callee7","_context7","_x13","_x14","_ref12","_this7","_callee9","_context9","_x15","_x16","HOST","PORT","SERVER","utils_getUrlParameter","param","URLSearchParams","location","search","replace","results","RegExp","exec","decodeURIComponent","utils_lazyLoadImages","lazyImages","slice","call","document","querySelectorAll","activeScroll","displayAndRemove","image","src","dataset","srcset","classList","remove","i","removeEventListener","lazyLoad","window","setTimeout","lazyImage","getBoundingClientRect","top","innerHeight","bottom","getComputedStyle","display","rect","left","documentElement","clientHeight","addEventListener","dom_makeImage","onload","sizes","alt","className","srcSet","restaurantImgUrl","makeStarRating","starCount","starsHTML","fill","join","populateSelectBox","selectEl","values","selectedValue","docFrag","createDocumentFragment","optionEl","createElement","childNodes","removeChild","lastChild","value","option","cloneNode","textContent","selected","appendChild","leaflet_src","Default","prototype","_getIconUrl","mergeOptions","iconRetinaUrl","marker_icon_2x_default","iconUrl","marker_icon_default","shadowUrl","marker_shadow_default","utils_Map","Map","mount","options","Map_classCallCheck","center","zoom","scrollWheelZoom","_map","_markers","attribution","addTo","markers","callback","bounds","position","content","extend","addMarker","fitBounds","setZoom","bindPopup","on","event","setView","target","getLatLng","marker","removeLayer","r","__webpack_exports__"],"mappings":"0RA4GAA,aAnGE,SAAAC,EAAYC,EAAQC,gGAASC,CAAAC,KAAAJ,GAC3BI,KAAKC,KAAOJ,EACZG,KAAKF,QAAUA,4DAQf,OAAOI,EAAAC,EAAIC,KAAKJ,KAAKC,KAAMD,KAAKF,QAAS,SAAAO,IAClCA,EAAGC,iBAAiBC,SAAS,gBAChCF,EAAGG,kBAAkB,eAAiBC,QAAS,OAG5CJ,EAAGC,iBAAiBC,SAAS,aAChBF,EAAGG,kBAAkB,WAAaC,QAAS,OACnDC,YAAY,aAAc,iBAG/BL,EAAGC,iBAAiBC,SAAS,oBACTF,EAAGG,kBAAkB,mBAC1CC,QAAS,KACTE,eAAe,IAEFD,YAAY,aAAc,qDAWrCE,EAAWC,GACnB,OAAOb,KAAKc,WAAWC,KAAK,SAAAV,GAC1B,IAAMW,EAAKX,EAAGY,YAAYL,EAAW,aASrC,OANIM,MAAMC,QAAQN,GAChBA,EAAKO,QAAQ,SAAAC,GAAA,OAAQL,EAAGM,YAAYV,GAAWW,IAAIF,KAEnDL,EAAGM,YAAYV,GAAWW,IAAIV,GAGzBG,EAAGQ,4CAULZ,GAAmC,IAAxBa,EAAwBC,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAlB,KAAMG,EAAYH,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAN,KACpC,OAAO1B,KAAKc,WAAWC,KAAK,SAAAV,GAC1B,IACMyB,EADKzB,EAAGY,YAAYL,GACTU,YAAYV,GAG7B,OAAKa,EAIDI,EACKC,EAAMC,MAAMF,GAAKG,OAAOP,GAI1BK,EAAMG,IAAIR,GARRK,EAAME,8CAYRpB,EAAWa,GACpB,OAAOzB,KAAKc,WAAWC,KAAK,SAAAV,GAM1B,OALWA,EACRY,YAAYL,EAAW,aACvBU,YAAYV,GACZsB,OAAOT,GAEAD,6CAIJZ,GACR,OAAOZ,KAAKc,WAAWC,KAAK,SAAAV,GAM1B,OALWA,EACRY,YAAYL,EAAW,aACvBU,YAAYV,GACZuB,QAEOX,gDCnGhB,MAAMY,EAINC,KAJMC,mBAAAC,KAAa,SAAAC,EAAMC,GAAN,OAAAH,mBAAAI,KAAA,SAAAC,GAAA,cAAAA,EAAAC,KAAAD,EAAAE,MAAA,OACH,OADGF,EAAAE,KAAA,EACGC,MAAML,GADT,OACV,OADUE,EAAAE,KAAA,EACVF,EAAAI,KAAyBC,OADf,cAAAL,EAAAM,OAAA,SAAAN,EAAAI,MAAA,wBAAAJ,EAAAO,SAAAV,EAAAxC,QAAboC,mQAAA,SAAAe,GAAA,OAAAf,EAAAgB,MAAApD,KAAA0B,aCJF2B,EAAS,MASXA,EAASC,EAAQ,KAAiBC,SAC3BC,KAAO,aAGhB,IAAAC,EAAA,uxBCVApD,ECwSA,eAlSE,SAAAqD,iGAAcC,CAAA3D,KAAA0D,GAEZ1D,KAAKK,GAAK,IAAIV,EAAS,qBAAsB,8GAW1BiE,EAAUC,oHAASC,iCAAQ,KAAMC,iCAAU,uBACvD,IAAIC,QAAJ,eAAAC,EAAAC,EAAA5B,mBAAAC,KAAY,SAAAC,EAAO2B,EAASC,GAAhB,IAAAC,EAAAC,EAAA,OAAAhC,mBAAAI,KAAA,SAAAC,GAAA,cAAAA,EAAAC,KAAAD,EAAAE,MAAA,OAIS,OAJTF,EAAAC,KAAA,EAAAD,EAAAE,KAAA,EAIeR,EAAAkC,UAAcC,EAAKC,OAAnB,KAAAC,OAA6Bd,IAJ5C,OAITS,EAJS1B,EAAAI,KAKfyB,EAAKnE,GAAGsE,UAAUd,EAASQ,GAE3BF,EAAQE,GAPO1B,EAAAE,KAAA,gBAWI,OAXJF,EAAAC,KAAA,EAAAD,EAAAiC,GAAAjC,EAAA,SAAAA,EAAAE,KAAA,GAWU2B,EAAKnE,GAAGwE,SAAShB,EAASC,EAAOC,GAX3C,SAWTO,EAXS3B,EAAAI,MAgBFoB,EAAQG,GAAcF,EAAOzB,EAAAiC,GAAME,SAhBjC,yBAAAnC,EAAAO,SAAAV,EAAAxC,OAAA,UAAZ,gBAAA+E,EAAAC,GAAA,OAAAf,EAAAb,MAAApD,KAAA0B,YAAA,yJAqBcuD,GAA4C,IAAnCC,EAAmCxD,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAvB1B,KAAKmF,iBAM/C,OALkBF,EAAQG,OAAO,SAACC,EAAKC,GACrC,OAAOD,EAAMC,EAAOC,QACnB,IACkCN,EAAQtD,OAASuD,GAAc,gDA+BtB,IAA7BM,EAA6BC,EAA7BD,GAAIE,EAAyBD,EAAzBC,KACrB,QAD8ChE,UAAAC,OAAA,QAAAC,IAAAF,UAAA,KAAAA,UAAA,GACvCiE,mBAAuBH,EAAvB,KAAAd,OAA6BgB,EAA7B,WAAAhB,OAA6C1E,KAAK4F,SAAlD,YAAAlB,OAAqEc,EAArE,KAAAd,OAA2EgB,EAA3E,8CASKF,GACZ,QADiC9D,UAAAC,OAAA,QAAAC,IAAAF,UAAA,KAAAA,UAAA,GAC1BiE,+BAAmCH,GAAnC,GAAAd,OAA6C1E,KAAK4F,SAAlD,wBAAAlB,OAAiFc,8CASxF,OAAOxF,KAAK6F,eAAe,cAAe,kEAQjB,IAClBC,EADkBC,EAAA/F,KACzB,OAAO,IAAIgE,SAAJ8B,EAAA5B,EAAA5B,mBAAAC,KAAY,SAAAyD,EAAO7B,EAASC,GAAhB,IAAA6B,EAAA,OAAA3D,mBAAAI,KAAA,SAAAwD,GAAA,cAAAA,EAAAtD,KAAAsD,EAAArD,MAAA,OAGK,OAHLqD,EAAAtD,KAAA,EAAAsD,EAAArD,KAAA,EAGWkD,EAAKI,mBAHhB,OAGTF,EAHSC,EAAAnD,KAMfoB,EAAQ8B,EAAYG,OAAO,SAAAC,GAAA,OAAAA,EAAGC,eANfJ,EAAArD,KAAA,gBAAAqD,EAAAtD,KAAA,EAAAsD,EAAAtB,GAAAsB,EAAA,SAQf9B,QARe,yBAAA8B,EAAAhD,SAAA8C,EAAAhG,OAAA,UAAZ,SAAAuG,EAAAC,GAAA,OAAAV,EAAA1C,MAAApD,KAAA0B,sDAkBO+E,GACd,OAAOzG,KAAK6F,eAAL,eAAAnB,OAAmC+B,GAAgB,cAAeA,0CAQzE,OAAOzG,KAAK6F,eAAe,UAAW,+CAQ5Ba,GACV,OAAO1G,KAAK6F,eAAL,WAAAnB,OAA+BgC,GAAY,UAAWA,kDAQxCD,GAAc,IAC5BE,EAD4BC,EAAA5G,KACnC,OAAO,IAAIgE,SAAJ2C,EAAAzC,EAAA5B,mBAAAC,KAAY,SAAAsE,EAAO1C,EAASC,GAAhB,IAAAa,EAAA6B,EAAA,OAAAxE,mBAAAI,KAAA,SAAAqE,GAAA,cAAAA,EAAAnE,KAAAmE,EAAAlE,MAAA,OAEC,OAFDkE,EAAAnE,KAAA,EAAAmE,EAAAlE,KAAA,EAEO+D,EAAKf,eAAL,0BAAAnB,OACM+B,GAC1B,UACAA,EACA,cANa,OAQQ,OANjBxB,EAFS8B,EAAAhE,KAAAgE,EAAAlE,KAAA,EAQc+D,EAAKvG,GAC/BwE,SAAS,kBAAmB4B,EAAc,cAC1C1F,KAAK,SAAAkE,GACJ,OAAOA,EAAQ+B,IAAI,SAAA1B,GACjB,OAAO2B,OAAOC,OAAO5B,GAAU6B,SAAS,QAZ/B,OAQTL,EARSC,EAAAhE,KAgBfoB,IAAY2C,GAAZpC,OAAA0C,EAA+BnC,KAhBhB8B,EAAAlE,KAAA,iBAAAkE,EAAAnE,KAAA,GAAAmE,EAAAnC,GAAAmC,EAAA,SAkBf3C,QAlBe,yBAAA2C,EAAA7D,SAAA2D,EAAA7G,OAAA,WAAZ,SAAAqH,EAAAC,GAAA,OAAAX,EAAAvD,MAAApD,KAAA0B,iEA4BkB+E,GAAc,IAChCc,EADgCC,EAAAxH,KACvC,OAAO,IAAIgE,SAAJuD,EAAArD,EAAA5B,mBAAAC,KAAY,SAAAkF,EAAOtD,EAASC,GAAhB,IAAAsD,EAAAzC,EAAA,OAAA3C,mBAAAI,KAAA,SAAAiF,GAAA,cAAAA,EAAA/E,KAAA+E,EAAA9E,MAAA,OAKF,OALE8E,EAAA/E,KAAA,EAAA+E,EAAA9E,KAAA,EAKI2E,EAAKI,gBAAgBnB,GALzB,OAML,OADViB,EALeC,EAAA5E,KAAA4E,EAAA9E,KAAA,EAMC2E,EAAKK,uBAAuBpB,GAN7B,OAMfxB,EANe0C,EAAA5E,KAOf2E,EAAWzC,QAAUA,MACrByC,EAAWI,cAAgBN,EAAKO,uBAAuBL,EAAWzC,SAClEd,EAAQuD,GATOC,EAAA9E,KAAA,iBAAA8E,EAAA/E,KAAA,GAAA+E,EAAA/C,GAAA+C,EAAA,SAWXD,IACFA,EAAWzC,QAAUA,MACrByC,EAAWI,cAAgBN,EAAKO,uBAAuBL,EAAWzC,SAClEd,EAAQuD,IAGVtD,QAjBe,yBAAAuD,EAAAzE,SAAAuE,EAAAzH,OAAA,WAAZ,SAAAgI,EAAAC,GAAA,OAAAV,EAAAnE,MAAApD,KAAA0B,0DA4BW4D,GAAQ,IACnB4C,EADmBC,EAAAnI,KAC1B,OAAO,IAAIgE,SAAJkE,EAAAhE,EAAA5B,mBAAAC,KAAY,SAAA6F,EAAOjE,EAASC,GAAhB,IAAAiE,EAAAC,EAAA,OAAAhG,mBAAAI,KAAA,SAAA6F,GAAA,cAAAA,EAAA3F,KAAA2F,EAAA1F,MAAA,OAWR,OAVHwF,GACJG,OAAQ,OACRC,KAAMC,KAAKC,UAAUrD,GACrBsD,QAAS,IAAIC,SACXC,eAAgB,sBALHP,EAAA3F,KAAA,EAAA2F,EAAA1F,KAAA,EAWFC,gBAASqF,EAAK1D,OAAd,YAAgC4D,GAX9B,OAWf,OAXeE,EAAA1F,KAAA,EAWf0F,EAAAxF,KAA4DC,OAX7C,OAYQ,OAZRuF,EAAA1F,KAAA,EAYcsF,EAAKN,uBAAuBvC,EAAOyD,eAZjD,OAYTT,EAZSC,EAAAxF,KAafoB,EAAQmE,GAbOC,EAAA1F,KAAA,iBAAA0F,EAAA3F,KAAA,GAAA2F,EAAA3D,GAAA2D,EAAA,SAgBfJ,EAAK9H,GACFsE,UAAU,kBAAmBW,GAC7BvE,KAAK,WACJoD,EAAQmB,KAET0D,MAAM,WACL5E,UAtBW,yBAAAmE,EAAArF,SAAAkF,EAAApI,OAAA,WAAZ,SAAAiJ,EAAAC,GAAA,OAAAhB,EAAA9E,MAAApD,KAAA0B,wDAgCS+E,GAAc,IACvB0C,EADuBC,EAAApJ,KAC9B,OAAO,IAAIgE,SAAJmF,EAAAjF,EAAA5B,mBAAAC,KAAY,SAAA8G,EAAOlF,EAASC,GAAhB,IAAA0C,EAAA,OAAAxE,mBAAAI,KAAA,SAAA4G,GAAA,cAAAA,EAAA1G,KAAA0G,EAAAzG,MAAA,OAMQ,OALpB0G,UAAUC,QACbpF,EAAO,IAAIqF,MAAM,qDAFFH,EAAA1G,KAAA,EAAA0G,EAAAzG,KAAA,EAMcuG,EAAK/I,GAAGwE,SAAS,mBAN/B,UAMTiC,EANSwC,EAAAvG,OAQX7B,MAAMC,QAAQ2F,IAAmBA,EAAenF,OAAS,GAR9C,CAAA2H,EAAAzG,KAAA,QASb,OATayG,EAAAzG,KAAA,EASPuG,EAAK/I,GAAGqJ,UAAU,mBATX,OAWb1F,QAAQ2F,IACN7C,EAAeE,IAAI,SAAA4C,GAA0D,IAAvDb,EAAuDa,EAAvDb,cAAe9I,EAAwC2J,EAAxC3J,KAAM4J,EAAkCD,EAAlCC,UAAWC,EAAuBF,EAAvBE,SAAUvE,EAAaqE,EAAbrE,OACxD8C,GACJG,OAAQ,OACRC,KAAMC,KAAKC,WAAYI,gBAAe9I,OAAM6J,WAAUD,YAAWtE,WACjEqD,QAAS,IAAIC,SACXC,eAAgB,sBAIpB,OAAOhG,gBAASsG,EAAK3E,OAAd,YAAgC4D,MAEzCtH,KAZFmD,EAAA5B,mBAAAC,KAYO,SAAAwH,IAAA,IAAAzB,EAAA,OAAAhG,mBAAAI,KAAA,SAAAsH,GAAA,cAAAA,EAAApH,KAAAoH,EAAAnH,MAAA,OACkB,OADlBmH,EAAAnH,KAAA,EACwBuG,EAAKvB,uBAAuBpB,GADpD,OACC6B,EADD0B,EAAAjH,KAELoB,EAAQmE,GAFH,wBAAA0B,EAAA9G,SAAA6G,EAAA/J,UAvBM,OAAAsJ,EAAAzG,KAAA,iBAAAyG,EAAA1G,KAAA,GAAA0G,EAAA1E,GAAA0E,EAAA,kCAAAA,EAAApG,SAAAmG,EAAArJ,OAAA,WAAZ,SAAAiK,EAAAC,GAAA,OAAAf,EAAA/F,MAAApD,KAAA0B,4DAoCa+E,EAAcH,GAAa,IACxC6D,EADwCC,EAAApK,KAC/C,OAAO,IAAIgE,SAAJmG,EAAAjG,EAAA5B,mBAAAC,KAAY,SAAA8H,EAAOlG,EAASC,GAAhB,IAAAC,EAAA,OAAA/B,mBAAAI,KAAA,SAAA4H,GAAA,cAAAA,EAAA1H,KAAA0H,EAAAzH,MAAA,OAEgB,OAFhByH,EAAA1H,KAAA,EAAA0H,EAAAzH,KAAA,EAEsBC,gBAChCsH,EAAK3F,OAD2B,iBAAAC,OACL+B,EADK,kBAAA/B,OACwB4B,IAEzDkC,OAAQ,QALG,OAES,OAFT8B,EAAAzH,KAAA,EAESyH,EAAAvH,KAKrBC,OAPY,OAETqB,EAFSiG,EAAAvH,KASfqH,EAAK/J,GAAGsE,UAAU,cAAeN,GACjCF,EAAQE,GAVOiG,EAAAzH,KAAA,iBAAAyH,EAAA1H,KAAA,GAAA0H,EAAA1F,GAAA0F,EAAA,SAYflG,EAAOkG,EAAA1F,GAAME,SAZE,yBAAAwF,EAAApH,SAAAmH,EAAArK,OAAA,WAAZ,SAAAuK,EAAAC,GAAA,OAAAL,EAAA/G,MAAApD,KAAA0B,+CA/NP,SAAAgD,OAAUjB,EAAOgH,MAAjB/F,OAAwBjB,EAAOiH,MAAP,IAAAhG,OAAmBjB,EAAOiH,sCAQlD,SAAAhG,OAAUjB,EAAOkH,iDAIjB,OAAO,wCClDXC,EAhBwB,SAAAC,GACtB,GAAKA,EAAL,CAGA,GAAIC,gBAEF,OADkB,IAAIA,gBAAgBC,SAASC,QAC9B/I,IAAI4I,GAIvBA,EAAQA,EAAMI,QAAQ,OAAQ,OAAOA,QAAQ,OAAQ,OACrD,IACMC,EADQ,IAAIC,OAAJ,SAAAzG,OAAoBmG,EAApB,cACQO,KAAKL,SAASC,QACpC,OAAmB,OAAZE,EAAmB,GAAKG,mBAAmBH,EAAQ,GAAGD,QAAQ,MAAO,QCoD9EK,EAlDuB,WACrB,IAAIC,KAAgBC,MAAMC,KAAKC,SAASC,iBAAiB,aACrDC,GAAe,EAEbC,EAAmB,SAAAC,GACvBA,EAAMC,IAAMD,EAAME,QAAQD,IAC1BD,EAAMG,OAASH,EAAME,QAAQC,OAC7BH,EAAMI,UAAUC,OAAO,QAIG,KAF1BZ,EAAaA,EAAWnF,OAAO,SAAAgG,GAAA,OAAKA,IAAMN,KAE3BnK,SACb+J,SAASW,oBAAoB,SAAUC,GACvCC,OAAOF,oBAAoB,SAAUC,GACrCC,OAAOF,oBAAoB,oBAAqBC,KAI9CA,EAAW,YACM,IAAjBV,IACFA,GAAe,EAEfY,WAAW,WACTjB,EAAWnK,QAAQ,SAAAqL,GAEfA,EAAUC,wBAAwBC,KAAOJ,OAAOK,aAChDH,EAAUC,wBAAwBG,QAAU,GACJ,SAAxCC,iBAAiBL,GAAWM,SAE5BlB,EAAiBY,KAIrBb,GAAe,GACd,OAKPL,EAAWnK,QAAQ,SAAAqL,GApDK,IAClBO,KAoDkBP,EApDRC,yBAGTC,KAAO,GACZK,EAAKC,MAAQ,GACbD,EAAKL,MAAQJ,OAAOK,aAAelB,SAASwB,gBAAgBC,eAgD1DtB,EAAiBY,KAIrBf,SAAS0B,iBAAiB,SAAUd,GACpCC,OAAOa,iBAAiB,SAAUd,GAClCC,OAAOa,iBAAiB,oBAAqBd,IC1DzCe,EAAY,SAAAjL,EAA6CkL,GAAW,IAArD9H,EAAqDpD,EAArDoD,GAAIuG,EAAiD3J,EAAjD2J,IAAKE,EAA4C7J,EAA5C6J,OAAQsB,EAAoCnL,EAApCmL,MAAOC,EAA6BpL,EAA7BoL,IAAKC,EAAwBrL,EAAxBqL,UAC1CC,EACJzB,aACG5L,EAASsN,kBAAmBnI,KAAIE,KAAM,UADzC,gBAAAhB,OAEErE,EAASsN,kBAAmBnI,KAAIE,KAAM,WAFxC,iBAAAhB,OAGErE,EAASsN,kBAAmBnI,KAAIE,KAAM,UAHxC,UAKF,yBAAAhB,OACSrE,EAASuF,SADlB,4CAAAlB,OAEcqH,EAFd,wBAAArH,OAGiBgJ,EAHjB,uBAAAhJ,OAIgB6I,EAJhB,kBAAA7I,OAKW+I,EALX,qBAAA/I,OAMS8I,EANT,YA0BII,EAAiB,SAAArI,GACrB,IAXMsI,EAWAC,GAXAD,EAAYxN,EAAS8E,iBACdjE,MAAM2M,GAAWE,KAAK,KACvBC,KAAK,KAWjB,uGAAAtJ,OAEkDa,GAAkB,EAFpE,OAAAb,OAE2EoJ,EAF3E,mDAAApJ,OAGuCoJ,EAHvC,2BAcIG,EAAoB,SAACC,EAAUC,EAAQC,GAM3C,IAJA,IAAMC,EAAU3C,SAAS4C,yBACnBC,EAAW7C,SAAS8C,cAAc,UAGjCN,EAASO,WAAW9M,OAAS,GAClCuM,EAASQ,YAAYR,EAASS,WAIhCR,EAAO/M,QAAQ,SAAAwN,GAEb,IAAIC,EAASN,EAASO,YAGtBD,EAAOE,YAAcH,EACrBC,EAAOD,MAAQA,EAEXA,IAAUR,IACZS,EAAOG,UAAW,GAIpBX,EAAQY,YAAYJ,KAItBX,EAASe,YAAYZ,gPC7EhBa,EAAA,KAAKC,QAAQC,UAAUC,YAE9BH,EAAA,KAAKC,QAAQG,cACXC,cAAeC,EAAArP,EACfsP,QAASC,EAAAvP,EACTwP,UAAWC,EAAAzP,QCbb0P,aDiBE,SAAAC,EAAYC,EAAOC,gGAASC,CAAAjQ,KAAA8P,GAO1BE,EAAU/I,OAAOC,WALfgJ,QAAS,WAAY,WACrBC,KAAM,GACNC,iBAAiB,GAGyBJ,GAG5ChQ,KAAKqQ,KAAO,IAAInB,EAAA,IAAWa,EAAOC,GAClChQ,KAAKsQ,YAGL,IAAIpB,EAAA,UAAU,sDACZqB,YACE,4FACDC,MAAMxQ,KAAK8P,+DAGLW,EAASC,GAAU,IAAAlM,EAAAxE,KACtB2Q,EAAS,IAAIzB,EAAA,aAEnBlP,KAAKsQ,SAAWG,EAAQzJ,IAAI,SAAA5E,GAA2B,IAAxBwO,EAAwBxO,EAAxBwO,SAAUC,EAAczO,EAAdyO,QAEvC,OADAF,EAAOG,OAAOF,GACPpM,EAAKuM,UAAUH,EAAUC,EAASH,KAGvC1Q,KAAKsQ,SAAS3O,OAAS,IACzB3B,KAAK8P,IAAIkB,UAAUL,GACnB3Q,KAAK8P,IAAImB,QAAQ,uCAIXL,GAAoC,IAAA7K,EAAA/F,KAA1B6Q,EAA0BnP,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAhB,KAAMgP,EAAUhP,UAAAC,OAAA,EAAAD,UAAA,QAAAE,EAC5C,OAAO,IAAIsN,EAAA,OAAO0B,GACfJ,MAAMxQ,KAAK8P,KACXoB,UAAUL,GACVM,GAAG,QAAS,SAAAC,GAGX,GAFArL,EAAK+J,IAAIuB,QAAQD,EAAME,OAAOC,aAE1Bb,EACF,OAAOA,EAASU,6CAKR,IAAAxK,EAAA5G,KACdA,KAAKsQ,SAASlP,QAAQ,SAAAoQ,GACpB5K,EAAKkJ,IAAI2B,YAAYD,iCAKvB,OAAOxR,KAAKqQ,qVExEhB/M,EAAAoO,EAAAC,GAMAA,EAAA,SALElH,KAAM,yCACNC,KAAM,GACNC,OAAQ","file":"./js/home~restaurant.min.js","sourcesContent":["import idb from 'idb';\n\nclass Database {\n  /**\n   * Creates a new IndexedDB data store, connects to the data store,\n   * and handles all CRUD (create, read, update, and delete) operations.\n   * @param {string} dbName The name of the data store.\n   * @param {number} version The data store version number. Increment when updating.\n   */\n  constructor(dbName, version) {\n    this.name = dbName;\n    this.version = version;\n  }\n\n  /**\n   * Connects to the database, or creates one\n   * @returns {Promise<*>} A Promise that resolves with the database object.\n   */\n  _connect() {\n    return idb.open(this.name, this.version, db => {\n      if (!db.objectStoreNames.contains('restaurants')) {\n        db.createObjectStore('restaurants', { keyPath: 'id' });\n      }\n\n      if (!db.objectStoreNames.contains('reviews')) {\n        const reviews = db.createObjectStore('reviews', { keyPath: 'id' });\n        reviews.createIndex('restaurant', 'restaurant_id');\n      }\n\n      if (!db.objectStoreNames.contains('pending-reviews')) {\n        const pendingReviews = db.createObjectStore('pending-reviews', {\n          keyPath: 'id',\n          autoIncrement: true\n        });\n        pendingReviews.createIndex('restaurant', 'restaurant_id');\n      }\n    });\n  }\n\n  /**\n   * Writes data to the database.\n   * @param {string} storeName The name of the data store you wish to write data to.\n   * @param {*} data The data you want to insert into the database.\n   * @returns {Promise<*>} A Promise that resolves when the transaction completes.\n   */\n  writeData(storeName, data) {\n    return this._connect().then(db => {\n      const tx = db.transaction(storeName, 'readwrite');\n\n      // Handle the case when data is an array\n      if (Array.isArray(data)) {\n        data.forEach(item => tx.objectStore(storeName).put(item));\n      } else {\n        tx.objectStore(storeName).put(data);\n      }\n\n      return tx.complete;\n    });\n  }\n\n  /**\n   * Reads data from the database.\n   * @param {*} storeName The name of the data store you wish to read data from.\n   * @param {*} key An optional key used to look up specific data records.\n   * @returns {Promise<*>} A Promise that resolves with the requested data.\n   */\n  readData(storeName, key = null, idx = null) {\n    return this._connect().then(db => {\n      const tx = db.transaction(storeName);\n      const store = tx.objectStore(storeName);\n\n      // If there is no key, return all the data.\n      if (!key) {\n        return store.getAll();\n      }\n\n      if (idx) {\n        return store.index(idx).getAll(key);\n      }\n\n      // Return just the data associated with the specified key.\n      return store.get(key);\n    });\n  }\n\n  deleteData(storeName, key) {\n    return this._connect().then(db => {\n      const tx = db\n        .transaction(storeName, 'readwrite')\n        .objectStore(storeName)\n        .delete(key);\n\n      return tx.complete;\n    });\n  }\n\n  clearData(storeName) {\n    return this._connect().then(db => {\n      const tx = db\n        .transaction(storeName, 'readwrite')\n        .objectStore(storeName)\n        .clear();\n\n      return tx.complete;\n    });\n  }\n}\n\nexport default Database;\n","/**\n * Uses the Fetch API to fetch resources from the network.\n * @param {string} url The URL of the resource to fetch.\n */\nconst asyncFetch = async url => {\n  return await (await fetch(url)).json();\n};\n\nexport default asyncFetch;\n","let config = null;\n\n// module.hot will be true in development and false in production\nif (module.hot) {\n  config = require('./config.dev').default;\n  config.MODE = 'development';\n}\nelse {\n  // import config.prod.js and export it\n  config = require('./config.prod').default;\n  config.MODE = 'production';\n}\n\nexport default config;\n","import Database from './Database';\nimport DBHelper from './DBHelper';\n\nexport default DBHelper;\n","import asyncFetch from '../asyncFetch';\nimport config from '../../config';\nimport Database from './Database';\n\nclass DBHelper {\n  /**\n   * Provides a layer of abstraction for interacting with the database\n   * and fetching network resources.\n   */\n  constructor() {\n    // Reference to an IndexedDB instance.\n    this.db = new Database('restaurant-reviews', 3);\n  }\n\n  /**\n   * Generic fetch method used internally by DBHelper to fetch resources.\n   * @param {string} resource The database resource that is being fetched. This value\n   * will be appended to the end of the API URL.\n   * @param {string} dbStore The name of the database store to read/write data to/from.\n   * @param {*} dbKey The key that will be used when retrieving data.\n   * @returns {Promise<*>} A Promise that resolves with the requested data or rejects with an error message.\n   */\n  async _fetchResource(resource, dbStore, dbKey = null, dbIndex = null) {\n    return new Promise(async (resolve, reject) => {\n      try {\n        // Retrieve data from the network, write the data to the database for offline use,\n        // and then resolve the Promise with the requested data.\n        const networkResponse = await asyncFetch(`${this.DB_URL}/${resource}`);\n        this.db.writeData(dbStore, networkResponse);\n\n        resolve(networkResponse);\n      } catch (error) {\n        // If we are here, it is likely there is a network error.\n        // Look for data in the database.\n        const dbResponse = await this.db.readData(dbStore, dbKey, dbIndex);\n\n        // If there is a database response, we must have data.\n        // In that case, resolve the Promise with the data.\n        // Otherwise, reject the Promise with the error message.\n        dbResponse ? resolve(dbResponse) : reject(error.message);\n      }\n    });\n  }\n\n  calculateAverageReview(reviews, maxReview = this.MAX_REVIEW_SCORE) {\n    const reviewSum = reviews.reduce((acc, review) => {\n      return acc + review.rating;\n    }, 0);\n    const averagePercent = (reviewSum / (reviews.length * maxReview)) * 100;\n\n    return averagePercent;\n  }\n\n  /**\n   * Reaches into the configuration variables and puts together the base URL for the client.\n   * @returns {string} The base URL for the client.\n   */\n  get BASE_URL() {\n    return `${config.HOST}${config.PORT && `:${config.PORT}`}`;\n  }\n\n  /**\n   * Reaches into the configuration variables to pull out the server URL.\n   * @returns {string} The URL of the API server.\n   */\n  get DB_URL() {\n    return `${config.SERVER}`;\n  }\n\n  get MAX_REVIEW_SCORE() {\n    return 5;\n  }\n\n  /**\n   * Takes in a restaurant object and returns the image URL.\n   * @param {object} restaurant The restaurant object, with id and size properties.\n   * @param {boolean} relative Whether to return a relative path (true) or absolute path (false). Default is true.\n   * @returns {string} The absolute or relative path to the restaurant image.\n   */\n  restaurantImgUrl({ id, size }, relative = true) {\n    return relative ? `./images/${id}-${size}.jpg` : `${this.BASE_URL}/images/${id}-${size}.jpg`;\n  }\n\n  /**\n   * Takes in a restaurant object and returns the URL to the restaurant page.\n   * @param {object} restaurant The restaurant object, with an id property.\n   * @param {boolean} relative Whether to return a relative path (true) or absolute path (false). Default is true.\n   * @returns {string} The absolute or relative path to the restaurant page.\n   */\n  restaurantUrl(id, relative = true) {\n    return relative ? `./restaurant.html?id=${id}` : `${this.BASE_URL}/restaurant.html?id=${id}`;\n  }\n\n  /**\n   * Fetches all restaurants. It will attempt to fetch from both the database and the network.\n   * If a response is received from the network, the database will be updated and returned.\n   * @returns {Promise<[object]>} Returns a Promise that resolves to an array of restaurant objects.\n   */\n  fetchRestaurants() {\n    return this._fetchResource('restaurants', 'restaurants');\n  }\n\n  /**\n   * Fetches all favorite restaurants. Under the hood, this uses the fetchRestaurants method\n   * and then filters the results before returning them.\n   * @returns {Promise<[*]>} A Promise that resolves to an array of restaurants.\n   */\n  fetchFavoriteRestaurants() {\n    return new Promise(async (resolve, reject) => {\n      try {\n        // First fetch all the restaurants.\n        const restaurants = await this.fetchRestaurants();\n\n        // Then filter the restaurants for favorites.\n        resolve(restaurants.filter(({ is_favorite }) => is_favorite));\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n\n  /**\n   * Looks for a particular restaurant with the given ID and returns it.\n   * @param {number} restaurantId The restaurant ID\n   * @return {Promise<object>} Returns a Promise that resolves to a restaurant object\n   */\n  fetchRestaurant(restaurantId) {\n    return this._fetchResource(`restaurants/${restaurantId}`, 'restaurants', restaurantId);\n  }\n\n  /**\n   * Fetches all restaurant reviews.\n   * @returns {Promise<[*]>} A Promise that resolves to an array of review objects.\n   */\n  fetchReviews() {\n    return this._fetchResource('reviews', 'reviews');\n  }\n\n  /**\n   * Fetches an individual restaurant review.\n   * @param {number} reviewId The ID of the review.\n   * @returns {Promise<[*]>} A Promise that resolves to a single review object.\n   */\n  fetchReview(reviewId) {\n    return this._fetchResource(`reviews/${reviewId}`, 'reviews', reviewId);\n  }\n\n  /**\n   * Fetches all reviews for a particular restaurant.\n   * @param {number} restaurantId The ID of the restaurant to return reviews for.\n   * @returns {Promise<[*]>} A Promise that resolves to an array of review objects.\n   */\n  fetchRestaurantReviews(restaurantId) {\n    return new Promise(async (resolve, reject) => {\n      try {\n        const reviews = await this._fetchResource(\n          `reviews/?restaurant_id=${restaurantId}`,\n          'reviews',\n          restaurantId,\n          'restaurant'\n        );\n        const pendingReviews = await this.db\n          .readData('pending-reviews', restaurantId, 'restaurant')\n          .then(reviews => {\n            return reviews.map(review => {\n              return Object.assign(review, { pending: true });\n            });\n          });\n\n        resolve([...pendingReviews, ...reviews]);\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n\n  /**\n   * Fetches a restaurant and all associated reviews.\n   * @param {*} restaurantId The ID of the restaurant to return.\n   * @returns {Promise<*>} A Promise that resolves to a restaurant object.\n   */\n  fetchRestaurantWithReviews(restaurantId) {\n    return new Promise(async (resolve, reject) => {\n      let restaurant;\n      let reviews;\n\n      try {\n        restaurant = await this.fetchRestaurant(restaurantId);\n        reviews = await this.fetchRestaurantReviews(restaurantId);\n        restaurant.reviews = reviews || [];\n        restaurant.averageReview = this.calculateAverageReview(restaurant.reviews);\n        resolve(restaurant);\n      } catch (error) {\n        if (restaurant) {\n          restaurant.reviews = reviews || [];\n          restaurant.averageReview = this.calculateAverageReview(restaurant.reviews);\n          resolve(restaurant);\n        }\n\n        reject(error);\n      }\n    });\n  }\n\n  // TODO: Finish the methods below\n\n  /**\n   *\n   * @param {object} review\n   */\n  addRestaurantReview(review) {\n    return new Promise(async (resolve, reject) => {\n      const fetchOptions = {\n        method: 'POST',\n        body: JSON.stringify(review),\n        headers: new Headers({\n          'Content-Type': 'application/json'\n        })\n      };\n\n      try {\n        // Attempt to post the new review\n        await (await fetch(`${this.DB_URL}/reviews`, fetchOptions)).json();\n        const updatedReviews = await this.fetchRestaurantReviews(review.restaurant_id);\n        resolve(updatedReviews);\n      } catch (error) {\n        // If that didn't work, save the review to be posted later\n        this.db\n          .writeData('pending-reviews', review)\n          .then(() => {\n            resolve(review);\n          })\n          .catch(() => {\n            reject(error);\n          });\n      }\n    });\n  }\n\n  /**\n   * Updates any reviews that are pending due to being offline.\n   * @param {number} restaurantId The ID of the restaurant to return the reviews for.\n   */\n  addPendingReviews(restaurantId) {\n    return new Promise(async (resolve, reject) => {\n      if (!navigator.onLine) {\n        reject(new Error('Unable to post pending reviews, you are offline.'));\n      }\n\n      try {\n        const pendingReviews = await this.db.readData('pending-reviews');\n\n        if (Array.isArray(pendingReviews) && pendingReviews.length > 0) {\n          await this.db.clearData('pending-reviews');\n\n          Promise.all(\n            pendingReviews.map(({ restaurant_id, name, createdAt, comments, rating }) => {\n              const fetchOptions = {\n                method: 'POST',\n                body: JSON.stringify({ restaurant_id, name, comments, createdAt, rating }),\n                headers: new Headers({\n                  'Content-Type': 'application/json'\n                })\n              };\n\n              return fetch(`${this.DB_URL}/reviews`, fetchOptions);\n            })\n          ).then(async () => {\n            const updatedReviews = await this.fetchRestaurantReviews(restaurantId);\n            resolve(updatedReviews);\n          });\n        }\n      } catch (error) {}\n    });\n  }\n\n  /**\n   *\n   * @param {number} restaurantId\n   */\n  setFavoriteRestaurant(restaurantId, is_favorite) {\n    return new Promise(async (resolve, reject) => {\n      try {\n        const networkResponse = await (await fetch(\n          `${this.DB_URL}/restaurants/${restaurantId}/?is_favorite=${is_favorite}`,\n          {\n            method: 'PUT'\n          }\n        )).json();\n\n        this.db.writeData('restaurants', networkResponse);\n        resolve(networkResponse);\n      } catch (error) {\n        reject(error.message);\n      }\n    });\n  }\n}\n\nexport default new DBHelper();\n","/**\n * Returns the value of the specified query string parameter\n * of the current URI.\n */\nconst getUrlParameter = param => {\n  if (!param) return;\n\n  // If URLSearchParams is supported, use that\n  if (URLSearchParams) {\n    const urlParams = new URLSearchParams(location.search);\n    return urlParams.get(param);\n  }\n\n  // Otherwise, parse the param using regular expressions\n  param = param.replace(/[\\[]/, '\\\\[').replace(/[\\]]/, '\\\\]');\n  const regex = new RegExp(`[\\\\?&]${param}=([^&#]*)`);\n  const results = regex.exec(location.search);\n  return results === null ? '' : decodeURIComponent(results[1].replace(/\\+/g, ' '));\n};\n\nexport default getUrlParameter;\n","/**\n * Helper function used in lazyLoadImages function to determine if the\n * element is currently within the bounding box of the browser window.\n * @param {*} el The DOM element to check\n * @returns {boolean} True if the element is inside the viewport, False otherwise.\n */\nconst elementInViewport = el => {\n  const rect = el.getBoundingClientRect();\n\n  return (\n    rect.top >= 0 &&\n    rect.left >= 0 &&\n    rect.top <= (window.innerHeight || document.documentElement.clientHeight)\n  );\n};\n\n/**\n * Lazy loads images\n */\nconst lazyLoadImages = () => {\n  let lazyImages = [].slice.call(document.querySelectorAll('img.lazy'));\n  let activeScroll = false;\n\n  const displayAndRemove = image => {\n    image.src = image.dataset.src;\n    image.srcset = image.dataset.srcset;\n    image.classList.remove('lazy');\n\n    lazyImages = lazyImages.filter(i => i !== image);\n\n    if (lazyImages.length === 0) {\n      document.removeEventListener('scroll', lazyLoad);\n      window.removeEventListener('resize', lazyLoad);\n      window.removeEventListener('orientationchange', lazyLoad);\n    }\n  };\n\n  const lazyLoad = () => {\n    if (activeScroll === false) {\n      activeScroll = true;\n\n      setTimeout(() => {\n        lazyImages.forEach(lazyImage => {\n          if (\n            lazyImage.getBoundingClientRect().top <= window.innerHeight &&\n            lazyImage.getBoundingClientRect().bottom >= 0 &&\n            getComputedStyle(lazyImage).display !== 'none'\n          ) {\n            displayAndRemove(lazyImage);\n          }\n        });\n\n        activeScroll = false;\n      }, 200);\n    }\n  };\n\n  // Remove images above the fold\n  lazyImages.forEach(lazyImage => {\n    if (elementInViewport(lazyImage)) {\n      displayAndRemove(lazyImage);\n    }\n  });\n\n  document.addEventListener('scroll', lazyLoad);\n  window.addEventListener('resize', lazyLoad);\n  window.addEventListener('orientationchange', lazyLoad);\n};\n\nexport default lazyLoadImages;\n","import DBHelper from './db';\n\n/**\n * Creates a responsive image.\n * @param {*} props The image properties (id, src, srcset, sizes, alt, className).\n * @param {function} onload The callback function to call once the image has loaded.\n * @returns {*} The HTML for the responsive image.\n */\nconst makeImage = ({ id, src, srcset, sizes, alt, className }, onload) => {\n  const srcSet =\n    srcset ||\n    `${DBHelper.restaurantImgUrl({ id, size: 'small' })} 800w,\n    ${DBHelper.restaurantImgUrl({ id, size: 'medium' })} 1200w,\n    ${DBHelper.restaurantImgUrl({ id, size: 'large' })} 1600w`;\n\n  return `<img \n    src=\"${DBHelper.BASE_URL}/images/placeholder.png\"\n    data-src=\"${src}\"\n    data-srcset=\"${srcSet}\"\n    data-sizes=\"${sizes}\"\n    class=\"${className} lazy\"\n    alt=\"${alt}\"\n  />`;\n};\n\n/**\n * Utility function that generates the stars used for the ratings.\n * @param {number} stars The number of stars to generate.\n * @returns {*} THe HTML for the stars that make up the star rating.\n */\nconst generateStarsHTML = () => {\n  const starCount = DBHelper.MAX_REVIEW_SCORE;\n  const html = Array(starCount).fill('★');\n  return html.join('');\n};\n\n/**\n * Generates the HTML output for a restaurant average star rating.\n * @param {number} rating The restaurants average rating.\n * @returns {*} The HTML for the restaurants star rating.\n */\nconst makeStarRating = rating => {\n  const starsHTML = generateStarsHTML();\n\n  return `\n    <div class=\"star-rating__container\">\n      <div class=\"star-rating__top\" style=\"width: ${rating ? rating : 0}%\">${starsHTML}</div>\n      <div class=\"star-rating__bottom\">${starsHTML}</div>\n    </div>\n  `;\n};\n\n/**\n * Utility function to populate a select box with values.\n * @param {*} selectEl The select element (HTML DOM element).\n * @param {[string]} values The values to populate the select element with.\n * @returns {undefined} Does not return a value.\n */\nconst populateSelectBox = (selectEl, values, selectedValue) => {\n  // Create a document fragment and option element\n  const docFrag = document.createDocumentFragment();\n  const optionEl = document.createElement('option');\n\n  // Clear all child nodes, except the first child\n  while (selectEl.childNodes.length > 1) {\n    selectEl.removeChild(selectEl.lastChild);\n  }\n\n  // Add an option for each value\n  values.forEach(value => {\n    // Clone the option element\n    let option = optionEl.cloneNode();\n\n    // Set the textContent and value\n    option.textContent = value;\n    option.value = value;\n\n    if (value === selectedValue) {\n      option.selected = true;\n    }\n\n    // Append the option to the document fragment\n    docFrag.appendChild(option);\n  });\n\n  // Append the document fragment to the select box\n  selectEl.appendChild(docFrag);\n};\n\nexport { makeImage, makeStarRating, populateSelectBox };\n","import { Map as LeafletMap, TileLayer, LatLngBounds, Icon, Marker } from 'leaflet';\n\n// Workaround to get markers working with leaflet when\n// bundling javascript with Webpack. Attribution:\n// https://github.com/PaulLeCam/react-leaflet/issues/255\nimport marker from 'leaflet/dist/images/marker-icon.png';\nimport marker2x from 'leaflet/dist/images/marker-icon-2x.png';\nimport markerShadow from 'leaflet/dist/images/marker-shadow.png';\n\ndelete Icon.Default.prototype._getIconUrl;\n\nIcon.Default.mergeOptions({\n  iconRetinaUrl: marker2x,\n  iconUrl: marker,\n  shadowUrl: markerShadow\n});\n\nclass Map {\n  constructor(mount, options) {\n    const defaultOptions = {\n      center: [40.722216, -73.987501],\n      zoom: 12,\n      scrollWheelZoom: false\n    };\n\n    options = Object.assign({}, defaultOptions, options);\n\n    // Create the map\n    this._map = new LeafletMap(mount, options);\n    this._markers = [];\n\n    // Add map tiles\n    new TileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {\n      attribution:\n        '&copy; <a href=\"https://www.openstreetmap.org/copyright\">OpenStreetMap</a> contributors'\n    }).addTo(this.Map);\n  }\n\n  addMarkers(markers, callback) {\n    const bounds = new LatLngBounds();\n\n    this._markers = markers.map(({ position, content }) => {\n      bounds.extend(position);\n      return this.addMarker(position, content, callback);\n    });\n\n    if (this._markers.length > 0) {\n      this.Map.fitBounds(bounds);\n      this.Map.setZoom(12);\n    }\n  }\n\n  addMarker(position, content = null, callback) {\n    return new Marker(position)\n      .addTo(this.Map)\n      .bindPopup(content)\n      .on('click', event => {\n        this.Map.setView(event.target.getLatLng());\n\n        if (callback) {\n          return callback(event);\n        }\n      });\n  }\n\n  removeMarkers() {\n    this._markers.forEach(marker => {\n      this.Map.removeLayer(marker);\n    });\n  }\n\n  get Map() {\n    return this._map;\n  }\n}\n\nexport default Map;\n","import Map from './Map';\nexport default Map;\n","const config = {\n  HOST: 'https://restaurant-reviews.netlify.com',\n  PORT: '',\n  SERVER: 'https://mws-restaurant-reviews.herokuapp.com',\n};\n\nexport default config;\n"],"sourceRoot":""}